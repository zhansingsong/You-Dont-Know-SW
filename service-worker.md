![PWA](./images/PWA.png)

一直以来，web app 想要做到与 native app 一样的用户体验。其中一个最重要的技术难道题是离线支持（离线状态下，也能访问页面）。虽然之前浏览器提供 [AppCache](https://developer.mozilla.org/en-US/docs/Web/HTML/Using_the_application_cache) 来支持离线访问。但 AppCache 在开发过程中暴露一些缺陷：

- 内容更新需要刷新两次才会生效
- manifest 文件的任何改变都会引起 manifest 中列举的所有文件都重新下载
- 一旦 manifest 文件下载完，浏览器就会同步下载 manifest 文件中列举的资源。这可能会阻塞页面的渲染。
- 不可靠的 API。如 `window.applicationCache.onupdateready` 有时在 iPhone 和 Android 设备上不会被触发。
- 更多参考：[Problems with Application Cache](http://blog.jamesdbloom.com/ProblemsWithApplicationCache.html)
- 其他相关文章：[Application Cache is a Douchebag](https://alistapart.com/article/application-cache-is-a-douchebag)

如何避免 AppCache 常见的问题

- [Tips for using Application Cache](http://blog.jamesdbloom.com/TipsForUsingApplicationCache.html)
- [Common Pitfalls to Avoid when using HTML5 Application Cache](https://www.sitepoint.com/common-pitfalls-avoid-using-html5-application-cache/)

让开发欣慰的事 AppCache 使用上相对容易，不过需要遵循诸多规则。如果不严格遵循这些规则，可能会适得其反，会让 app 体验变得更糟糕。AppCache 的诸多不足，最终让它从 Web 规范中被移除，并被 Service worker 代替。虽然 Service worker 使用上比 AppCache 更复杂。但这样可让开发人员更加精细地控制缓存行为，能很好地避免 AppCache 的问题。

## 什么是 Service Worker(SW)?

> The easiest way to think about service workers is as a piece of code that is installed by a site on a client machine, runs in the background, and subsequently enables requests sent to that site to be intercepted and manipulated. —— Simon Jones

Service Worker 是一个安装在客户端，运行在后台，能拦截和操作 web app 请求的脚本。

> singsong: 为了方便理解，可以将 Service Worker 看成一个介于客户端与服务端的代理服务。如 Fiddler、Charles。

## Service Worker 能做什么

Service Worker(SW）是一种新兴的浏览器技术，它除了能让 web app 拥有离线体验外，还有
[消息推送](https://developers.google.com/web/fundamentals/codelabs/push-notifications/)、[后台更新](https://github.com/WICG/BackgroundSync/blob/master/explainer.md)、[定期更新](https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerRegistration/periodicSync)、[地理围栏](https://developers.google.com/location-context/geofencing/)等功能。这让 web app 可在浏览器中提供类似 native app 一样的用户体验。它也是
[progressive web apps（PWA）](https://inviqa.com/blog/how-get-started-progressive-web-apps)一个核心组成部分。
Service Worker 功能很强大👍，再介绍如何使用 Service Worker 之前，需要了解一下 Service Worker 的特性及生命周期。这样才能更好地使用它。

## Service Worker 特性
Service Worker 本身也是 [worker](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers)，即它也有 worker 的特性：

* 运行在自己的上下文中(线程)
* 不能访问 DOM

除了拥有 worker 的特性外，它还有自己的特有特性：

* 事件驱动
* 异步
* 安全(HTTPS)
* 更新模型
* 顶级导航匹配

### 事件驱动

如果将 Service Worker 设计成 与 [shared worker](https://html.spec.whatwg.org/multipage/workers.html#sharedworker) 一样。即它生命周期与它所控制的页面关联。这样只有当它所控制的所有页面或窗口都关闭了，Service Worker 才会被回收。如果页面没有关闭，Service Worker 会一直运行。而且随着启动 Service Worker 数量增多，消耗资源和电源更多，这对移动端影响更大。

因此，考虑性能问题，Service Worker 采用了事件驱动模式。当某个事件（**install**, **activate**, **message**, **fetch**, **push**等）触发时会启动 Service Worker，事件执行完后就终止掉。

如果没有事件让 Service Worker 保持工作，浏览器就可以随时关闭 Service Worker，并回收 Service Worker 所使用的资源。当再有事件被触发，Service Worker 会被重新激活。

> Service workers intentionally have very short lifespans. They are "born" in response to a specific event (install, activate, message, fetch, push, etc.), perform their task, and then "die" shortly thereafter. The lifespan is normally long enough that multiple events might be handled (i.e. an install might be followed by an activate followed by a fetch) before the worker dies, but it will die eventually. This is why it's very important not to rely on any global state in your scripts, and to bootstrap any state information you need via IndexedDB or the Cache Storage API when your Service Worker starts up. [more info ……](https://stackoverflow.com/questions/29741922/prevent-service-worker-from-automatically-stopping)

另外，由于 Service Worker 会频繁地重启，所以不能依赖全局变量(global state)在事件处理函数之间共享状态。因为每次 Service Worker 重启都会重新初始化全局状态。如果需要共享状态，可以使用 [IndexedDB API](https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API) 或 [Cache API](https://developer.mozilla.org/en-US/docs/Web/API/Cache) 将数据本地持久化。[更多详情……](https://stackoverflow.com/questions/38835273/when-does-code-in-a-service-worker-outside-of-an-event-handler-run/38835274#38835274)

> singsong：当 Service Worker 处于 Idle（空闲）时，浏览器会某个时间段内终止掉sw。这个时间段对每个浏览器都不一样。有1m或30s。[Chrome 使用30s](https://groups.google.com/a/chromium.org/forum/#!topic/chromium-reviews/xVXklMLtekY)。[更多详情……](https://love2dev.com/blog/service-worker-termination/)

### 异步

Service Worker 几乎所有工作都依赖于 DOM 事件作为入口。除 `importScripts()` 外，Service Worker 支持 APIs 都是异步的（即不能使用同步 [Local Storage](https://flaviocopes.com/web-storage-api/) 和 [XHR](https://flaviocopes.com/xhr/) APIs）。如下是一些常用 APIs：

  - [Channel Messaging API](https://flaviocopes.com/channel-messaging-api/)
  - [Fetch API](https://flaviocopes.com/fetch-api/)
  - [Cache API](https://flaviocopes.com/cache-api/)
  - [Promises](https://flaviocopes.com/javascript-promises/)


而 Service Worker 又是事件驱动的，当事件处理函数执行完事件就随之结束。此时，可能事件处理函数中的异步操作还没执行完。为了确保异步操作的完整性，这里可以调用 [`e.waitUntil()`](#event.waitUntil(f)) 和 [`e.respondWith()`](#event.respondWith(r)) 延长事件的生命周期。

另外，长时间运行或 CPU 密集型工作可能导致 Service Worker 无法响应。这种情况下，可以将计算工作委托给其他 worker。且这些 worker 会随着 Service Worker 终止而终止。



### 安全

Service Worker 的功能很强大，因此需要有对应的安全限制来防止它被滥用。
- [只能在安全环境下工作——**HTTPS**（开发环境，可以使用**localhost**、127.0.0.0/8、::1/128）](https://w3c.github.io/ServiceWorker/#secure-context)。
- 遵循[同源策略](https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy)。
- `scope`(作用范围)。
  一般我们会将 Service Worker 的作用范围设置为项目的 root 目录(`/sw.js`)。这样 Service Worker 可以控制站点`/`的所有请求。如果将其设置为`/js/sw.js`，那 Service Worker 就只能控制`/js`下的请求。而`/`下的请求是不被受影响的。为什么要这样设置？

  > singsong: Service Worker 脚本文件的地址是相对于 origin，而不是 app 的根目录。
  
  假如有个商城平台：www.mall.com，并且允许第三方商家站点入驻。现在有两个商家(假如：huawei、mi)入驻：www.mall.com/huawei，www.mall.com/mi。假如商家 huawei 上传 Service Worker 到它站点（www.mall.com/huawei/sw.js）。浏览器如果没有对 Service Worker 作用范围做限制，`/huawei/sw.js` 就可以控制商家 mi 的流量导向，甚至 www.mall.com 的流量导向。为了避免类似情况发生，浏览器会对 Service Worker 作用范围做限制。Service Worker 只对所在目录和子目录有影响。这里我们可以通过浏览器提供的`scope`选项指定：

  ```js
  // 作用范围一样。即如果不指定scope，默认为sw.js所在目录
  navigator.serviceWorker.register('/sw.js');
  navigator.serviceWorker.register('/sw.js', { scope: '/' });
  ```

  如果要对不同的商家设定不同的 scope，可以这样设置：

  ```js
  navigator.serviceWorker.register('/sw-huawei.js', { scope: '/huawei' });
  navigator.serviceWorker.register('/sw-mi.js', { scope: '/mi' });
  ```

### [更新模型](https://github.com/w3c/ServiceWorker/blob/master/explainer.md#updating-a-service-worker)

Service Worker 的更新模型与 Chrome 类似：在不打扰用户前提下，在后台进行更新操作。在旧版本 Service Worker 卸载后完成更新。

无论何时只要进入安装了 Service Worker 的页面。浏览器都会在后台检查 Service Worker 脚本是否更新。[即使是一字节的变化，浏览器都会将 Service Worker 脚本视为新的 Service Worker 脚本](https://w3c.github.io/ServiceWorker/#update-algorithm)。接着会将其安装、激活、取代旧版本 Service Worker 控制当前页面。不过如果被旧版本 Service Worker 控制的页面仍在运行，此时新版本 Service Worker 会处于 waiting 状态。只有当旧版本 Service Worker 控制的所有页面都关闭了（如关闭在旧 Service Worker 作用范围内的 window 或 tab，或跳转到不在旧 Service Worker 作用范围内的页面）。旧版本 Service Worker 才会被回收，新版本 Service Worker 激活并接管控制页面。

> singsong: 浏览器只对 Service Worker 脚本做检查，不会检查脚本中`importScripts`引用外部脚本。另外，还需要注意的是，浏览器缓存机制对 Service Worker 脚本的影响。如`max-age`。如果服务器对 Service Worker 脚本设置`max-age`大于 24 小时，在这种情况浏览器会将`max-age`设置为 24 小时。即 Service Worker 脚本缓存有效期最大为一天时长。[更多详情……](https://stackoverflow.com/questions/38843970/service-worker-javascript-update-frequency-every-24-hours/38854905#38854905)

### 顶级导航匹配

为了优化性能，浏览器会维护一个 `scope` 到 [Service Worker Registration](https://w3c.github.io/ServiceWorker/#service-worker-registration-concept) 映射关系。称为 **Registration map**。 这样能快速地查找对应的 Service Worker。当请求(fetch)一个顶级文档导航时，为了确定由哪个 Server worker 来处理。浏览器会获取当前 `origin + URL` 执行匹配。一旦匹配成功会执行对应的 Service Worker 脚本实例化 Service Worker（如果当前没有运行的 Service Worker 实例）控制当前页面。[具体匹配算法……](https://w3c.github.io/ServiceWorker/#scope-match-algorithm)

![](./images/client-match.png)

另外，为了进一步优化，匹配算法只对顶级文档导航工作，随后的子资源的请求都会被发送到控制当页面的 Service Worker。这里的顶级文档导航即页面请求或页面第一个请求。如[https://www.zhansingsong.com/](https://www.zhansingsong.com/) 页面：
> ![](./images/top-level-navigation.png)

## Service Worker 生命周期

当一个页面注册一个新的 Service Worker 时，会经过如下状态：
![Service Worker lifecycle](./images/lifecycle.png)

- Installing

  当用 `navigator.serviceWorker.register` 新注册一个 Service Worker 时。浏览器会下载这个 Service Worker 文件，并解析，然后进入 **Installing** 状态。如果安装成功，则会进入 **Installed** 状态。否则脚本会被丢弃，然后进入 **Redundant** 状态。
  另外，可以使用`event.waitUntil()`来扩展 `install` 事件。该方法接受一个 promise，只有当这个 promise 被 fulfilled 或 rejected 后。Service Worker 才能确定安装已完成。如果 promise 被 rejected，则 Service Worker 进入 **Redundant** 状态。

- Installed/Waiting

  一旦 Service Worker 安装成功，进入到 **Installed** 状态后。接着会立即进入到 activating 状态。但如果当前页面已被存在活动的 Service Worker 控制，这种情况下 新的 Service Worker 会等待去控制当前页面。所以这个状态也称为 **waiting** 状态。

- Activating

  在 Service Worker 被激活，且控制当前页面之前。`activate` 事件会被触发。该事件与 `install` 事件类似，可以使用`event.waitUntil()` 方法扩展 `activate`事件的生命周期。

- Activated

  当 Service Worker 被成功激活，并且控制当前页面。就可以监听页面的 `fetch` 事件，拦截页面中的请求。

  ~~> singsong: 一个 Service Worker 是在页面加载之前控制它们的。即在 Service Worker 进入 active 状态之前那些已加载完的页面，Service Worker 是不能控制它们的。~~

- Redundant

  Service Worker 只要在注册、安装期间失败，或被别的 Service Worker 取代。都会进入 **Redundant** 状态。这种状态下的 Service Worker 不会对你的程序产生任何影响。另外，在事件处理函数中非法操作（如无限循环和处理事件时存在超时的处理任务）也会导致 Service Worker 进入 **Redundant** 状态。

> The browser can terminate a running SW thread at almost any time. Chrome terminates a SW if the SW has been idle for 30 seconds. Chrome also detects long-running workers and terminates them. It does this if an event takes more than 5 minutes to settle, or if the worker is busy running synchronous JavaScript and does not respond to a ping within 30 seconds. When a SW is not running, Developer Tools and chrome://serviceworker-internals show its status as STOPPED. [more info ……](https://dev.chromium.org/Home/chromium-security/security-faq/service-worker-security-faq)

如果 Service Worker 在激活后，没有接收到任何 functional events，就会进入 idle 状态。闲置一段时间（如30s）后，Service Worker 就进入 terminated 状态。这并不意味着 Service Worker 已被卸载，因为此时还可以接收 functional events。只有当 Service Worker 完全被卸载后，就会进入 **Redundant** 状态。

![](https://mdn.mozillademos.org/files/12636/sw-lifecycle.png)

> singsong：一个 Service Worker 和它状态是独立于任何一个浏览器窗口或 tab 项。即只要一个 Service Worker 成功被激活。它会直接保持此状态。即使有相同页面在新窗口打开，浏览器会尝试再次安装 Service Worker。如果浏览器检测到已经注册了这个 Service Worker，它就不会再次被安装。

### Service Worker 所支持的事件

Service Worker 之所以能拦截请求，主要是因为它能拦截 Service Worker 上下文中的事件。事件包括：lifecycle events，functional events，message events。[更多事件……](https://w3c.github.io/ServiceWorker/#execution-context-events)

| lifecycle events | functional events | message events |
| :--------------: | :---------------: | :------------: |
| install          | fetch             | message        |
| activate         | sync              |                |
|                  | push              |                |
|                  | notificationclick |                |

lifecycle events，functional events 和 message events 的共同点都继承了 [ExtendableEvent](https://w3c.github.io/ServiceWorker/#extendableevent)。ExtendableEvent 能延长事件的生命周期。每个 ExtendableEvent 都有一个关联的 [extend lifetime promises](https://w3c.github.io/ServiceWorker/#extendableevent-extend-lifetime-promises) 数组，只有当 extend lifetime promises 中待处理的 promises 都被处理，才会结束事件。具体操作由 ExtendableEvent 提供的 `event.waitUntil(f)` 方法来完成。


#### event.waitUntil(f)

[event.waitUntil(f)](https://w3c.github.io/ServiceWorker/#wait-until-method) 方法接受一个 promise 参数 f。直到 f 被 fulfilled 或 rejected，事件才会结束。该方法一般用于 `install`、`activate` 事件中，用于确保异步操作完整性。另外，不能在 ExtendableEvent 处理函数外部调用 `waitUntil()` 方法。否则会报 `InvalidStateError` 错误。

> Service workers delay treating the installing worker as installed until all the promises in the install event’s extend lifetime promises resolve successfully. If any of the promises rejects, the installation fails. This is primarily used to ensure that a Service Worker is not considered installed until all of the core caches it depends on are populated. Likewise, service workers delay treating the active worker as activated until all the promises in the activate event’s extend lifetime promises settle. (See the relevant Activate algorithm step.) This is primarily used to ensure that any functional events are not dispatched to the Service Worker until it upgrades database schemas and deletes the outdated cache entries. [more info ……](https://w3c.github.io/ServiceWorker/#dom-extendableevent-waituntil)

#### event.respondWith(r)

[event.respondWith(r)](https://w3c.github.io/ServiceWorker/#fetch-event-respondwith) 是 [FetchEvent](https://w3c.github.io/ServiceWorker/#wait-until-method) 的方法，用于 `fecth` 事件中，定制响应。与 `event.waitUntil(r)` 一样，也能扩展事件生命周期。不同的是参数 r 是一个 [Response](https://developer.mozilla.org/en-US/docs/Web/API/Response) 的 promise。

> [event.respondWith(r)](https://w3c.github.io/ServiceWorker/#dom-fetchevent-respondwith) extends the lifetime of the event by default as if [event.waitUntil(r)](https://w3c.github.io/ServiceWorker/#dom-extendableevent-waituntil) is called.

#### 粒子 🌰

```js
self.addEventListener('push', function() {
  fetch('/updates').then(function(response) {
    return self.registration.showNotification(response);
  });
});
```

这里为了方便讲解，使用了 `push` 事件([Push API](https://developer.mozilla.org/en-US/docs/Web/API/Push_API))，关于 `push` 读者只需知道当服务器 push 一个消息给客户端时，就会触发这个事件。当`push`事件被触发，此时在事件处理函数中会尝试从服务器请求`'/updates'`数据，并向客户端推送最新的数据。
不过这代码是有问题的。因为这里的 fetch 请求是异步的。当 `push` 事件的回调函数执行完，如果 Service Worker 上下文中没有其他事件被触发，浏览器就会随时终止 Service Worker。但可能此时 `'/update'` 的请求响应还没返回，从而导致异常错误产生。
如何让浏览器在 fetch 请求完成后再终止 Service Worker？这里就可以使用 `waitUntil()` 方法来扩展 `push` 事件的生命周期。

```js
self.addEventListener('push', function(event) {
  event.waitUntil(
    fetch('/updates').then(function() {
      return self.registration.showNotification(response);
    })
  );
});
```

`event.waitUntil()` 方法会让 `push` 事件等待 `fetch` 请求和 `showNotification` 调用完成后才会终止 Service Worker。
除了 `event.waitUntil()` 方法可扩展 Service Worker 事件生命周期外， `event.respondWith()` 也可以，不过它是 [FetchEvent](https://developer.mozilla.org/zh-CN/docs/Web/API/FetchEvent) 特有的方法。

```js
self.addEventListener('fetch', function(event) {
  if (event.request.url === '/') {
    event.respondWith(fetch('/update').then(response => response));
  } else {
    // do something...
  }
});
```

本文到此，已对 Service Worker 有了初步的认识。那究竟如何使用它，让 web app 拥有更好的用户体验？

## 如何使用 Service Worker

前文在对 Service Worker 做介绍时了解到 Service Worker 是个 JavaScript 文件。这里假设这个文件为：`sw.js`，且位于项目根目录下。至于 `sw.js` 内容本文后面会讲解到。要使用 Service Worker 第一步骤，就是注册 `sw.js` 文件。首先得检测浏览器是否支持 Service Worker。如果支持，在文档加载完就注册 `sw.js` 文件。

### 注册

```js
/* main.js */
if ('serviceWorker' in navigator) {
  window.addEventListener('load', () => {
    navigator.serviceWorker.register('/sw.js').then(
      function(registration) {
        // Registration was successful
        console.log(
          'ServiceWorker registration successful with scope: ',
          registration.scope
        );
      },
      function(err) {
        // registration failed :(
        console.log('ServiceWorker registration failed: ', err);
      }
    );
  });
} else {
  console.log('Service Workers not supported');
}
```

> singsong：假设这里注册代码是在 main.js 文件中

当浏览器开始注册 `sw.js` 时，会先从 `/sw.js` 路径下下载 `sw.js`，然后解析。如果解析成功就可以访问 Service Worker 的注册对象 registration。这个对象包含了一些 Service Worker 信息，如当前状态、scope 等。如果注册失败 `sw.js` 文件会被丢弃。一旦解析成功，Service Worker 就会进入下个状态：**Installing**

### 安装

浏览器在尝试安装 Service Worker 时，可以通过 `registration.installing` 获取 Service Worker 是否处在安装状态：

```js
/* main.js */
navigator.serviceWorker.register('./sw.js').then((registration) => {
  if (registration.installing) {
    // Service Worker is Installing
  }
});
```

在安装期间，浏览器会触发 Service Worker 的 `install` 事件。一般可以在这个事件对一些静态资源进行预缓存处理：

```js
/* sw.js */
const VERSION = 'V1';
const currentCacheName = `filesToCache-${VERSION}`;
const assetsToCache = ['demo.jpg', 'demo.css', 'demo.js'];
self.addEventListener('install', (event) => {
  event.waitUntil(
    // 扩展install的执行周期，直到cache返回的promise被fulfilled或rejected。
    caches.open(currentCacheName).then((cache) => {
      // 打开currentCacheName缓存
      return cache.addAll(assetsToCache); // 将资源存到cache中
    })
  );
});
```

这里使用 `event.waitUntil()` 方法来确保缓存操作已完成。它能扩展 Service Worker 的 `install` 事件的执行周期，直到 cache 返回的 promise 被 fulfilled 或 rejected（如果为 rejected，service worker 会进入 **redundant** 状态）。因为`cache.addAll()` 方法是异步的。可能存在当 install 事件执行完，`cache.addAll()` 还没有完成缓存操作。当 Service Worker 安装成功后就会进入 **installed** 状态，如果当前存在其他 Service Worker 控制 Clients，它需要等待去控制 Clients。所以这个状态也称为 **waiting** 状态。


当然这里可以调用 [ServiceWorkerGlobalScope.skipWaiting()](https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerGlobalScope/skipWaiting) 方法，跳过等待过程，直接进入 **activating** 状态。

```js
/* main.js */
navigator.serviceWorker.register('./sw.js').then((registration) => {
  if (registration.waiting) {
    self.skipWaiting();
  }
});
```
如下场景都会让一个 waiting 状态的 Service Worker 进入 activating 状态：

- 没有活动 Service Worker。
- 调用 [ServiceWorkerGlobalScope.skipWaiting()](https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerGlobalScope/skipWaiting) 方法。
- 控制 Clients 的 Service Workers 被回收。如离开页面、Service Worker 文件过期等。

### 激活

Service Worker 在激活期间，会触发 `activate` 事件，一般可以在该事件处理函数中对旧缓存进行删除处理。

```js
const VERSION = "V1";
const currentCacheName = `filesToCache-${VERSION}`;
/* sw.js */
self.addEventListener('activate', (event) => {
  event.waitUntil(
    // Get all the cache names
    caches.keys().then((cacheNames) => {
      return Promise.all(
        // Get all the items that are stored under a different cache name than the current one
        cacheNames
          .filter((cacheName) => {
            return cacheName != currentCacheName;
          })
          .map((cacheName) => {
            // Delete the items
            return caches.delete(cacheName);
          })
      ); // end Promise.all()
    }) // end caches.keys()
  ); // end event.waitUntil()
});
```

类似于 install 事件，这里也使用 `event.waitUntil()` 方法扩展 `activate` 事件的执行周期。同样只要`event.waitUntil()` 接受的 promise 被 rejected，Service Worker 就会变为 **redundant** 状态。

### 网络拦截

当 Service Worker 激活后，Service Worker 就完全控制 app。此时就可以使用 `fetch` 事件拦截请求。

```js
self.addEventListener('fetch', (event) => {
  console.log(event.request);
});
```
`event.request` 对象包含了请求相关的信息：URL、method 和请求头的信息。另外，需要注意的是：Service Worker 的 `fetch` 事件可以拦截当前页面内任何请求，即使它们是来自另一个来源。如 CSS、JS、images、XHR 等。但除了如下情况例外：

- iframe 和 `<object>` —— 这些会根据其的 URL 选择自己的 Service Worker。
- Service Worker —— 获取或更新一个 Service Worker 的请求不会经过当前 Service worker。
- 在一个 Service Worker 中触发的请求。

除了可以劫持请求外，还可以定制响应：

```js
self.addEventListener('fetch', (event) => {
  event.respondWith(new Response('Hello world!'));
});
```

在Service Worker 激活后，还可以使用 `message` 事件与 window 或其他 worker 进行通信。

```js
self.addEventListener('message', (event) => {
  // Do stuff with postMessages received from document
});
```

实战操作可以参考 Google 的官方实例：[Adding a Service Worker and Offline into your Web App](https://codelabs.developers.google.com/codelabs/offline/index.html?index=..%2F..index#0)

## 如何在生产项目中使用

在实际生产中，对于小项目来说，手动维护一个 `sw.js` 脚本，成本在可接受范围内。但对于稍微复杂项目，手动维护可能就吃不消了。因为每次项目迭代，都需要重新编写 `sw.js`。加上如果项目需要维护资源较多，出错的几率增大。那有木有专门的自动化工具来替我们维护这个 `sw.js` 脚本呢？

答案肯定是有的。再讲解如何自动化维护 `sw.js` 脚本之前，先要了解一些概念。在搭建一个 PWA 时，一般会使用到 **App shell + Dynamic content** 模型，这是一种将应用逻辑与内容分离的架构。

### App shell

web app 的"壳"，类似于 native app 的安装包。包含了让 web app 离线运行的所有静态资源。如 html、css、js、image 等。如果站点完全是静态的，这个"壳"就是应用的所有静态资源了。

### Dynamic content

动态内容是使用 JavaScript 通过网络获取的。如 API 数据。
![](https://developers.google.com/web/fundamentals/architecture/images/appshell.png)

了解 **App shell + Dynamic content** 架构后。针对 **App shell** 和 **Dynamic content** 可以分别使用如下如模块进行处理：

### [sw-precache](https://github.com/GoogleChromeLabs/sw-precache)

> A node module to generate Service Worker code that will precache specific resources so they work offline.

一个用于生成预缓存特定资源的 Service Worker 文件的 node 模块。它除了可以生成 Service Worker 文件外，还可以预缓存资源。很适合用来处理 **App shell**。

缓存最大的问题是如何保障缓存资源是最新的同时，还要确保冗余资源的回收。sw-precache 为了跟踪每个要缓存的资源，会根据每个资源的内容生成一个 hash 值。然后将每个资源的版本 hash 值与 URL 保存在 Service Worker 文件中。再对预缓存的资源使用 [cache-first](https://googlechromelabs.github.io/sw-toolbox/api.html#toolboxcachefirst) 策略进行缓存。这样就可以确保当某个预缓存资源发生改变时，无需更新全部资源，只需更新变化的资源即可。另外，sw-precache 也可以与 [sw-toolbox](https://github.com/GoogleChrome/sw-toolbox) 协同工作。使用 sw-precache 提供`runtimeCaching`配置项，可让 [sw-toolbox](https://github.com/GoogleChrome/sw-toolbox) 与 sw-precache 协同工作。

### [sw-toolbox](https://github.com/GoogleChrome/sw-toolbox)

为了对 **Dynamic content** 做到更精细的控制。sw-toolbox 提供了一种基于路由应用不同缓存策略的使用方式。同时它还通过 [IndexedDB](https://developer.mozilla.org/zh-CN/docs/Web/API/IndexedDB_API) 提供了 `cache.maxEntries` 和 `cache.maxAgeSeconds` 缓存选项，可控制缓存项的数量和缓存有效期。当然它也提供预缓存功能。不过与 sw-precache 相比，在对预缓存处理上 sw-toolbox 显得有些粗暴。因为每次 Service Worker 文件的更新，都会将之前预缓存资源全部删除，然后重新下载缓存。[更多关于 sw-toolbox 详情](https://googlechromelabs.github.io/sw-toolbox/api.html#main)。

- 路由

  - Express-style Routes
  - Regular Expression Routes

- 缓存策略

  - toolbox.networkFirst
  - toolbox.cacheFirst
  - toolbox.fastest
  - toolbox.cacheOnly
  - toolbox.networkOnly

更多关于 sw-precache 与 sw-toolbox 的关系，可以参考：[sw-precache? sw-toolbox? What's the difference?](https://github.com/GoogleChromeLabs/sw-precache/blob/master/sw-precache-and-sw-toolbox.md)

### 自动生成 Service Worker 文件

要实现自动化生成 Service Worker 文件，这就得借助自动化构建工具，如 [webpack](https://webpack.js.org/)、[rollup](https://rollupjs.org/guide/en)、[gulp](https://gulpjs.com/) 等。这里以 webpack 为例讲解。上文已介绍 sw-precache 除了可以生成 Service Worker 文件外，同时具备处理 **App shell** 和 **Dynamic content** 的能力。官方也提供了基于 webpack 的插件：[sw-precache-webpack-plugin](https://www.npmjs.com/package/sw-precache-webpack-plugin)。这是个 webpack 插件，配合 sw-precache 自动生成 Service Worker 文件。webpack 在打包时，会根据依赖树生成项目所依赖的静态资源，这些都是预缓存资源。该插件会在 webpack 触发 `emit` 后，从编译对象上获取这些信息，并将其注入到 sw-precache 中。

如下是我个人 blog 站点的 sw-precache-webpack-plugin 插件的配置信息：

```js
 new SWPrecacheWebpackPlugin({
    staticFileGlobs: ['publics/favicon.ico', 'publics/service-worker-registration.js'],
    mergeStaticsConfig: true,
    // Brute force server worker routing:
    // Tell the Service Worker to use /shell for all navigations.
    // E.g. A request for /guides/12345 will be fulfilled with /shell
    navigateFallback: '/',
    stripPrefix: 'publics',
    dynamicUrlToDependencies: {},
    fakeDynamicUrlToDependencies:
      {
        'index.html': '/index',
        'archives.html': '/archives',
        'tags.html': '/tags',
        'about.html': '/about',
        'categories.html': '/categories',
        'articles.html': '/articles',
        'offline.html': '/offline',
        '404.html': '/404',
      },
    // API Updates: https://github.com/GoogleChromeLabs/sw-toolbox/issues/98
    runtimeCaching: [
      {
        urlPattern: /\.(png|jpeg|jpg|webp|gif)/,
        handler: 'cacheFirst',
        options: {
          cache: {
            name: `imgs-cache-v${SW_VERSION}`,
            maxEntries: 50,
          },
        },
      },
      {
        urlPattern: '/api/github/(.*)',
        handler: function(req, vals, opts) { // eslint-disable-line
          return toolbox.fastest(req, vals, opts).catch(function(error) { // eslint-disable-line
            self.sendMessageToClients('/offline'); // eslint-disable-line
            throw error;
          });
        },
        options: {
          cache: {
            name: `apis-cache-v${SW_VERSION}`,
            // Use sw-toolbox's LRU expiration.
            maxEntries: 50,
            maxAgeSeconds: 86400,
          },
        },
      },
      {
        urlPattern: '/api/(.*)',
        handler: function(req, vals, opts) { // eslint-disable-line
          return toolbox.networkFirst(req, vals, opts).catch(function(error) { // eslint-disable-line
            self.sendMessageToClients('/offline'); // eslint-disable-line
            throw error;
          });
        },
        options: {
          cache: {
            name: `apis-cache-v${SW_VERSION}`,
            // Use sw-toolbox's LRU expiration.
            maxEntries: 50,
            maxAgeSeconds: 86400,
          },
        },
      },
      {
        urlPattern: '/articles/:article',
        handler: function(req, vals, opts) { // eslint-disable-line
          return toolbox.networkFirst(req, vals, opts).catch(function(error) { // eslint-disable-line
            if (req.method === 'GET' && req.headers.get('accept').includes('text/html')) {
              return toolbox.cacheOnly(new Request(urlsToCacheKeys.get(`${self.location.origin}/offline`)), vals, { cache: {name: cacheName} });
            }
            throw error;
          });
        },
      },
      {
        default: 'toolbox.networkFirst',
      },
    ],
    // By default, a cache-busting query parameter is appended to requests
    // used to populate the caches, to ensure the responses are fresh.
    // If a URL is already hashed by Webpack, then there is no concern
    // about it being stale, and the cache-busting can be skipped.
    dontCacheBustUrlsMatching: /\.\w{8}\./,
    filename: 'service-worker.js',
    minify: true,
    // For unknown URLs, fallback to the index page
    // navigateFallback: publicUrl + '/index.html',
    // Ignores URLs starting from /__ (useful for Firebase):
    // https://github.com/facebookincubator/create-react-app/issues/2237#issuecomment-302693219
    navigateFallbackWhitelist: [/^(?!\/__).*/],
    // Don't precache sourcemaps (they're large) and build asset manifest:
    staticFileGlobsIgnorePatterns: [/\.html$/, /\.map$/, /asset-manifest\.json$/],
  }),
```

这里对关键代码做一下讲解：

```js
staticFileGlobs: ['publics/favicon.ico', 'publics/service-worker-registration.js'],
mergeStaticsConfig: true,
```

`staticFileGlobs` 配置项主要用来增加外部预缓存资源。因为可能存在有些想要预缓存的资源没在 webpack 处理范围内。这里还需要配合 `mergeStaticsConfig: true` 一起使用。不然只会缓存 `staticFileGlobs` 指定的资源，而忽略掉 webpack 生成的资源。

```js
dynamicUrlToDependencies: {},
fakeDynamicUrlToDependencies:
  {
    'index.html': '/index',
    'archives.html': '/archives',
    'tags.html': '/tags',
    'about.html': '/about',
    'categories.html': '/categories',
    'articles.html': '/articles',
    'offline.html': '/offline',
    '404.html': '/404',
  },
```

`dynamicUrlToDependencies` 配置项是用来指定一个 URL 到 URL 内容所依赖的文件、字符串、buffer 的映射。简单点说，就预缓存 URL。前提是当 URL 内容发生改变时，预缓存的内容也要得到更新。而 URL 的内容是否发生变化直接与所依赖的文件、字符、buffer 有关。如：

```js
dynamicUrlToDependencies: {
'/pages/home': ['layout.jade', 'home.jade']
}
```

`'/pages/home'` 的内容是由模板文件 `'layout.jade'` 和 `'home.jade'` 共同决定。sw-precache 会读取 `'layout.jade'` 和 `'home.jade'` 文件生成一个 hash 值，这个 hash 值决定了 `'/pages/home'` 是否发生变化。其处理方式与 sw-precache 处理预缓存是一样的。

这里有个问题：依赖的模板文件过多维护起来不是很方便；而如果不列举完所依赖的模板文件，URL 是发生变化就无法得到保障。所以这里自己对插件做一些定制，通过 `fakeDynamicUrlToDependencies` 去生成 `dynamicUrlToDependencies`。 `fakeDynamicUrlToDependencies` 指定 HTML 文件到 URL 的映射关系，插件会根据 `fakeDynamicUrlToDependencies` 从 webpack 中获取对应的 HTML 文件字符串。然后使用字符串与 URL 生成 `dynamicUrlToDependencies`。

```js
runtimeCaching: [
  /* sw-toolbox 配置 */
];
```

`runtimeCaching` 配置项是用来配置 **sw-toolbox** 的使用。要使用好 **sw-toolbox**。关键是对缓存策略合理应用。

```js
{
  urlPattern: /\.(png|jpeg|jpg|webp|gif)/,
  handler: 'cacheFirst',
  options: {
    cache: {
      name: `imgs-cache-v${SW_VERSION}`,
      maxEntries: 50,
    },
  },
},
```

图片资源很少发生变化，所以使用了 `cacheFirst` 缓存策略，并缓存在单独的 cache 中，同时对缓存想数量做了最大 50 条的限制。但对于请求接口就不能使用 `cacheFirst` 缓存策略，因为它对实时性要求比较高。

`name: 'imgs-cache-v${SW_VERSION}'`，这里在命名中使用版本变量 `SW_VERSION`。为什么要这样处理？当使用单独的缓存来保存资源时，即不使用 sw-toolbox 默认缓存。这种情况需要开发者自己维护这个缓存。增加版本号，主要方便删除老版本的缓存。

```js
{
  urlPattern: '/api/(.*)',
  handler: function(req, vals, opts) { // eslint-disable-line
    return toolbox.networkFirst(req, vals, opts).catch(function(error) { // eslint-disable-line
      self.sendMessageToClients('/offline'); // eslint-disable-line
      throw error;
    });
  },
  options: {
    cache: {
      name: `apis-cache-v${SW_VERSION}`,
      // Use sw-toolbox's LRU expiration.
      maxEntries: 50,
      maxAgeSeconds: 86400,
    },
  },
},
{
  urlPattern: '/api/github/(.*)',
  handler: function(req, vals, opts) { // eslint-disable-line
    return toolbox.fastest(req, vals, opts).catch(function(error) { // eslint-disable-line
      self.sendMessageToClients('/offline'); // eslint-disable-line
      throw error;
    });
  },
  options: {
    cache: {
      name: `apis-cache-v${SW_VERSION}`,
      // Use sw-toolbox's LRU expiration.
      maxEntries: 50,
      maxAgeSeconds: 86400,
    },
  },
},
```

`'/api/(.*)'` 接口使用了 `networkFirst` 缓存策略，这种策略会让每次对`'/api/(.*)'`的请求，都会直接从网络获取。因为可能存在网络请求失败情况，为了提高用户体验，这里对请求失败的情况做了回退处理。只要请求一失败，会通知客户端直接跳转到预缓存`'/offlline'`页面。

而 `'/api/github/(.*)'` 接口却使用了`fastest`策略。因为这个接口更新不是很频繁，对实时性要求不是很高。

```js
{
  urlPattern: '/articles/:article',
  handler: function(req, vals, opts) { // eslint-disable-line
    return toolbox.networkFirst(req, vals, opts).catch(function(error) { // eslint-disable-line
      if (req.method === 'GET' && req.headers.get('accept').includes('text/html')) {
        return toolbox.cacheOnly(new Request(urlsToCacheKeys.get(`${self.location.origin}/offline`)), vals, { cache: {name: cacheName} });
      }
      throw error;
    });
  },
},
{
  default: 'toolbox.networkFirst',
},
```

另外，对 `'/articles/:article'` 请求页面也做缓存处理。如果页面获取失败直接响应 `'offline'` 。其他就使用 `default: 'toolbox.networkFirst'` 默认缓存策略。最后生成的代码：

```js
toolbox.router.get(/\.(png|jpeg|jpg|webp|gif)/, toolbox.cacheFirst, {"cache":{"name":"imgs-cache-v1","maxEntries":50}});
toolbox.router.get("/api/github/(.*)", function handler(req, vals, opts) {
      // eslint-disable-line
      return toolbox.fastest(req, vals, opts).catch(function (error) {
        // eslint-disable-line
        self.sendMessageToClients('/offline'); // eslint-disable-line
        throw error;
      });
    }, {"cache":{"name":"apis-cache-v1","maxEntries":50,"maxAgeSeconds":86400}});
toolbox.router.get("/api/(.*)", function handler(req, vals, opts) {
      // eslint-disable-line
      return toolbox.networkFirst(req, vals, opts).catch(function (error) {
        // eslint-disable-line
        self.sendMessageToClients('/offline'); // eslint-disable-line
        throw error;
      });
    }, {"cache":{"name":"apis-cache-v1","maxEntries":50,"maxAgeSeconds":86400}});
toolbox.router.get("/articles/:article", function handler(req, vals, opts) {
      // eslint-disable-line
      return toolbox.networkFirst(req, vals, opts).catch(function (error) {
        // eslint-disable-line
        if (req.method === 'GET' && req.headers.get('accept').includes('text/html')) {
          return toolbox.cacheOnly(new Request(urlsToCacheKeys.get(self.location.origin + '/offline')), vals, { cache: { name: cacheName } });
        }
        throw error;
      });
    }, {});
toolbox.router.default = toolbox.networkFirst;
```
> singsong: 如何使用好缓存策略，这是对开发人员的考验。
完整的 Service Worker 文件代码：[猛击这里查看](./service-worker.js)

除了可以使用 sw-precache 和 sw-toolbox 生成 Service Worker 文件外。还可以使用 Workbox。

### [Workbox](https://developers.google.com/web/tools/workbox/)
> Workbox is a library that bakes in a set of best practices and removes the boilerplate every developer writes when working with service workers.

它是一个提供了一序列使用 Service Worker 最佳实践的集合库。Workbox 基于功能细划模块，减小冗余代码同时也提高了模块复用性，在使用上与 sw-precache 和 sw-toolbox 相比，Workbox 更加灵活。
Workbox 除了具备 sw-precache 和 sw-toolbox 功能外。它还拥有 **Background sync**、**Helpful debugging** 等功能。另外，Workbox 与 sw-precache 和 sw-toolbox 都是同一个开发团队推出的，都是为了解决更好地使用 Service Worker。[更多关于 Workbox](https://developers.google.com/web/tools/workbox/reference-docs/latest/)。


## Service Worker Cache

Service Worker 规范定义了两个缓存相关的 API：

- [CacheStorage]([CacheStorage](https://developer.mozilla.org/en-US/docs/Web/API/CacheStorage))
- [Cache](https://developer.mozilla.org/en-US/docs/Web/API/Cache)

在 Service Worker 中做持久化时，常会使用这个两个接口。为了方便理解，这里以 [mongoDB](https://www.mongodb.com/) 做个类比：

- CacheStorage 类似 mongodb 服务。管理所有的 Cache，是整个缓存入口。在  Service Worker 上下文中通过 `caches` 获取。

- Cache 类似 mongodb 中 database。

Service Worker Cache 并没有取代了 Browser/HTTP cache。

- Browser/HTTP Cache
  
  浏览器默认的缓存方式。一般只能由 HTTP header 控制。没有任何 JavaScript API 可以直接控制它。不过可以通过一些技巧越过它。如在请求参数中增加个版本号或时间戳等
- Service Worker Cache
  
  这是一种用于 Service Worker 新兴缓存。它不仅仅是一个新的缓存 API，且完全独立于浏览器标准缓存。它存储在一个单独的地方，并以不同的方式管理。即 HTTP header 是不能影响它的。

### 缓存顺序

Service Worker Cache 是不能影响 Browser/HTTP Cache。要使用好 Service Worker Cache，需要理解浏览器对 Service Worker Cache 和 Browser/HTTP Cache 处理顺序：

![](./images/pwa-cache-en-cascade.png)

当用户发起一个请求时，浏览器处理顺序如下：

1. 尝试从 Service Worker Cache 获取请求资源。如果 Service Worker Cache 存在请求资源，直接响应。此时就不往下走了。
2. 尝试从 Browser Cache 获取请求资源。当 Service Worker Cache 没存在请求资源，会走到 Browser Cache，并检查 Browser Cache 是否存在请求资源。如果存在，直接响应。
3. 从 server 获取请求资源。如果当请求资源都没有缓存在 Service Worker Cache 和 Browser Cache，浏览器会 fetch 请求给 server。

从缓存顺利处理图也可以知道：

- 当注册了 Service Worker 后，Service Worker 就能控制任何请求
- Service Worker 是不能直接控制浏览器是否从服务器上获取请求数据
- [更多详情……](https://enux.pl/article/en/2018-05-05/pwa-and-http-caching)



## 参考文章

- [The Service Worker Lifecycle](https://bitsofco.de/the-service-worker-lifecycle/)
- [Service Worker Security FAQ](https://dev.chromium.org/Home/chromium-security/security-faq/service-worker-security-faq)
- [Service Workers Nightly](https://w3c.github.io/ServiceWorker/#motivations)
- [The offline cookbook](https://jakearchibald.com/2014/offline-cookbook/)
- [How to Fix the Refresh Button When Using Service Workers](https://redfin.engineering/how-to-fix-the-refresh-button-when-using-service-workers-a8e27af6df68)
- [How to display a "new version available" for a Progressive Web App](https://deanhume.com/displaying-a-new-version-available-progressive-web-app/)